{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"reprexlite: Python reproducible examples for sharing","text":"<p>reprexlite is a tool for rendering reproducible examples of Python code for sharing. With a convenient CLI and lightweight dependencies, you can quickly get it up and running in any virtual environment. It has an optional integration with IPython for easy use with IPython or in Jupyter or VS Code. This project is inspired by R's reprex package.</p> <p></p>"},{"location":"#what-it-does","title":"What it does","text":"<ul> <li>Paste or type some Python code that you're interested in sharing.</li> <li>reprexlite will execute that code in an isolated namespace. Any returned values or standard output will be captured and displayed as comments below their associated code.</li> <li>The rendered reprex will be printed for you to share. Its format can be easily copied, pasted, and run as-is by someone else. Here's an example of an outputted reprex:</li> </ul> <pre><code>from itertools import product\n\ngrid = list(product([1, 2, 3], [8, 16]))\ngrid\n#&gt; [(1, 8), (1, 16), (2, 8), (2, 16), (3, 8), (3, 16)]\nlist(zip(*grid))\n#&gt; [(1, 1, 2, 2, 3, 3), (8, 16, 8, 16, 8, 16)]\n</code></pre> <p>Writing a good reprex takes thought and effort (see \"Reprex Do's and Don'ts\" for tips). The goal of reprexlite is to be a tool that seamlessly handles the mechanical stuff, so you can devote your full attention to the important, creative work of writing the content.</p> <p>Reprex-style code formatting\u2014namely, with outputs as comments\u2014is also great for documentation. Users can copy and run with no modification. Consider using reprexlite when writing your documentation instead of copying code with <code>&gt;&gt;&gt;</code> prompts from an interactive Python shell. In fact, reprexlite can parse code with <code>&gt;&gt;&gt;</code> prompts and convert it into a reprex for you instead.</p> <p>reprexlite is a lightweight alternative to reprexpy and is similarly meant as a port of the R package reprex.</p>"},{"location":"#why-reproducible-examples","title":"Why reproducible examples?","text":"<p>If you're asking for help or reporting a bug, you are more likely to succeed in getting others to help you if you include a good reprex. If you're writing documentation, your readers will appreciate examples that they can easily run. See \"Design Philosophy\" for more on both \"Why reproducible examples?\" and \"Why reprexlite?\"</p>"},{"location":"#installation","title":"Installation","text":"<p>reprexlite is available on PyPI:</p> <pre><code>pip install reprexlite\n</code></pre> <p>Optional dependencies can be specified using the \"extras\" mechanism, e.g., <code>reprexlite[ipython]</code>. Available extras are:</p> <ul> <li><code>black</code> : for optionally autoformatting your code</li> <li><code>ipython</code> : to use the IPython interactive shell editor or <code>%%reprex</code> IPython cell magic</li> <li><code>pygments</code> : for syntax highlighting and rendering the output as RTF</li> </ul>"},{"location":"#development-version","title":"Development version","text":"<p>The development version of reprexlite is available on GitHub:</p> <pre><code>pip install https://github.com/jayqi/reprexlite.git#egg=reprexlite\n</code></pre>"},{"location":"#basic-usage","title":"Basic usage","text":""},{"location":"#command-line-interface","title":"Command-line interface","text":"<p>The easiest way to use reprexlite is through the CLI. It allows you to create a reprex without entering a Python session. Simply invoke the command:</p> <pre><code>reprex\n</code></pre> <p>This will take you into your system's default command-line text editor where you can type or paste your Python code. On macOS, for example, this will be <code>vim</code>. You can set your default editor using the <code>$VISUAL</code> or <code>$EDITOR</code> environment variables\u2014I'm personally a fan of <code>nano</code>/<code>pico</code>.</p> <p>Once you're done, reprexlite will print out your reprex to console.</p> <p>To see available options, use the <code>--help</code> flag.</p>"},{"location":"#ipython-integrations","title":"IPython integrations","text":"<p>There are two kinds of IPython integration:</p> <ol> <li>IPython interactive shell editor, which opens up a special IPython session where all cells are run through reprexlite</li> <li>Cell magics, which let you designate individual cells in a normal IPython or Jupyter notebook for being run through reprexlite</li> </ol>"},{"location":"#ipython-interactive-shell-editor","title":"IPython interactive shell editor","text":"<p>Requires IPython. <code>[ipython]</code></p> <p>reprexlite optionally supports an IPython interactive shell editor. This is basically like a normal IPython interactive shell except that all cells are piped through reprexlite for rendering instead of the normal cell execution. It has the typical advantages of using IPython like auto-suggestions, history scrolling, and syntax highlighting.  You can start the IPython editor by using the <code>--editor</code>/<code>-e</code> option:</p> <pre><code>reprex -e ipython\n</code></pre> <p>If you need to configure anything, use the other CLI options alongside the editor option when launching the shell.</p> <p>Compared to using the IPython cell magic (next section), you don't need to load the reprexlite extension or write out the <code>%%reprex</code> cell magic every use.</p>"},{"location":"#ipythonjupyter-cell-magic","title":"IPython/Jupyter Cell Magic","text":"<p>Requires IPython. <code>[ipython]</code></p> <p>reprexlite also has an optional IPython extension with a <code>%%reprex</code> cell magic. That means you can easily create a reprex in an IPython shell (requires IPython), in Jupyter (requires Jupyter), or in VS Code's Interactive Python window (requires ipykernel). This can be handy if you're already working in a Jupyter notebook and want to share some code and output, which otherwise doesn't neatly copy and paste in a nice format.</p> <p>To use, simply load the extension with</p> <pre><code>%load_ext reprexlite\n</code></pre> <p>and then put <code>%%reprex</code> at the top of a cell you want to create a reprex for:</p> <pre><code>%%reprex\nfrom itertools import product\n\ngrid = list(product([1, 2, 3], [8, 16]))\ngrid\nlist(zip(*grid))\n</code></pre> <p>The magic accepts the same inline option flags as the CLI. Use the line magic <code>%reprex</code> (note single <code>%</code>) to print out help. See the documentation for more details.</p>"},{"location":"#python-library","title":"Python library","text":"<p>The same functionality as the CLI is also available from the <code>reprex</code> function with an equivalent API. Simply pass a string with your code, and it will print out the reprex, as well as return a <code>Reprex</code> object that contains all the data and formatting machinery. See the API documentation for more details.</p> <pre><code>from reprexlite import reprex\n\ncode = \"\"\"\nfrom itertools import product\n\ngrid = list(product([1, 2, 3], [8, 16]))\ngrid\nlist(zip(*grid))\n\"\"\"\n\nreprex(code)\n#&gt; ```python\n#&gt; from itertools import product\n#&gt;\n#&gt; grid = list(product([1, 2, 3], [8, 16]))\n#&gt; grid\n#&gt; #&gt; [(1, 8), (1, 16), (2, 8), (2, 16), (3, 8), (3, 16)]\n#&gt; list(zip(*grid))\n#&gt; #&gt; [(1, 1, 2, 2, 3, 3), (8, 16, 8, 16, 8, 16)]\n#&gt; ```\n#&gt;\n#&gt; &lt;sup&gt;Created at 2021-02-26 00:32:00 PST by [reprexlite](https://github.com/jayqi/reprexlite) v0.3.0&lt;/sup&gt;\n#&gt; &lt;reprexlite.formatting.GitHubReprex object at 0x109059f10&gt;\n</code></pre>"},{"location":"alternatives/","title":"Alternatives","text":""},{"location":"alternatives/#python-alternatives","title":"Python Alternatives","text":""},{"location":"alternatives/#reprexpy","title":"reprexpy","text":"<p>A more faithful port of the user experience of R's reprex package. This tool supports reading input from your clipboard and writing the output back to your clipboard. It also supports matplotlib plots by automatically uploading image files for the plot to imgur. It works by running your code in Jupyter notebooks behind the scenes.</p>"},{"location":"alternatives/#r-alternatives","title":"R Alternatives","text":""},{"location":"alternatives/#reprex","title":"reprex","text":"<p>The original reprex tool created and maintained by developers from RStudio/Posit and the tidyverse community.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#v100-2025-02-15","title":"v1.0.0 (2025-02-15)","text":"<p>This release involves major changes to reprexlite. There is a significant refactoring of the library internals and also many changes to the API. This enabled new feature and more customizability.</p> <p>This release also removes support for Python 3.6, 3.7, and 3.8.</p>"},{"location":"changelog/#cli-and-ipython-user-interfaces","title":"CLI and IPython User Interfaces","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added a new <code>--editor</code>/<code>-e</code> option to specify what editor to use. If not used, this has same behavior as before. This option is also the new way to launch the IPython interactive shell editor (by passing <code>ipython</code>).</li> <li>Added new options to control parsing and output style.<ul> <li><code>--prompt</code> and <code>--continuation</code> options let you set the primary and secondary prompt prefixes in rendered output. These default to empty srings <code>\"\"</code> for \"reprex-style\" output.</li> <li>A new <code>--parsing-method</code> option controls input-parsing behavior.<ul> <li>The default value <code>auto</code> can automatically handle \"reprex-style\" input as well as \"doctest-style`/Python REPL input.</li> <li>A value <code>declared</code> will use the values of <code>--prompt</code>, <code>--continuation</code>, and <code>--comment</code> for parsing input in addition to styling output. To handle input and output with different styes, you can override input-side values with the <code>--input-prompt</code>, <code>--input-continuation</code>, and <code>--input-comment</code> options.</li> </ul> </li> </ul> </li> <li>Added support for configuration files, including support for <code>[tool.reprexlite]</code> in <code>pyproject.toml</code> files and for user-level configuration. See \"Configuration\" for more details.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Changed the way to access the IPython interactive shell editor. This is now launched by using the new <code>--editor</code>/<code>-e</code> option by passing <code>ipython</code>. The IPython shell editor also now respects other command line configuration options. It is now considered a stable feature and is no longer experimental.</li> <li>Renamed the <code>--old-results</code> option to <code>--keep-old-results</code>.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed bug that silenced output when using the IPython cell magic or the IPython shell editor and encountering an error where reprexlite couldn't render your code (such as a syntax error). This should now display an informative error message.</li> </ul>"},{"location":"changelog/#library","title":"Library","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Added new <code>reprexlite.parsing</code> module which contains functions for parsing input. These functions yield tuples representing lines of the input with an enum indicating whether the line is code or a result.</li> <li>Added new <code>reprexlite.reprexes</code> module which contains code for evaluating a reprex.<ul> <li>The new <code>Reprex</code> dataclass serves as the main container for reprex data. It holds parallel lists of <code>Statement</code>, <code>ParsedResult</code>, and <code>RawResult</code> data.<ul> <li>The <code>Reprex.from_input_lines</code> factory method creates a <code>Reprex</code> from the output of the <code>reprexlite.parsing</code> parsing functions.</li> <li>The <code>Reprex.from_input</code> factory method wraps parsing and takes a string input.</li> </ul> </li> <li>The <code>Statement</code> dataclass holds code data and parsed concrete syntax tree. This serves a similar purpose to the old <code>Statement</code> class.</li> <li>The <code>ParsedResult</code> dataclass holds old evaluation results parsed from the input, if any.</li> <li>The <code>RawResult</code> dataclass holds the returned values from evaluating code. This serves a similar purpose to the old <code>Result</code> class.</li> </ul> </li> <li>Added new <code>reprexlite.config</code> module and <code>ReprexConfig</code> dataclass for holding configuration values.</li> <li>Added new <code>reprexlite.exceptions</code> module with exception classes that subclass a base exception class <code>ReprexliteException</code>.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Changed formatting abstractions in <code>reprexlite.formatting</code> module.<ul> <li>Rather than <code>*Reprex</code> classes that encapsulate reprex data, we now have formatter callables and take a rendered reprex output string as input and appropriately prepares the reprex output for a venue, such as adding venue-specific markup.</li> <li>The <code>venues_dispatcher</code> dictionary in <code>reprexlite.formatting</code> is now a <code>formatter_registry</code> dictionary-like.</li> <li>Formatters are added to the registry using a <code>formatter_registry.register</code> decorator instead of being hard-coded.</li> </ul> </li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed <code>reprexlite.code</code> module. The functionality in this module was reimplemented in the new <code>reprexlite.reprexes</code> and <code>reprexlite.parsing</code> modules.</li> <li>Removed <code>reprexlite.reprex</code> module. The <code>reprex</code> function has been moved to <code>reprexlite.reprexes</code>.</li> </ul>"},{"location":"changelog/#general","title":"General","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Added a \"Rendering and Output Venues\" page to the documentation that documents the different formatting options with examples.</li> <li>Added a \"Configuration\" page to the documentation that provides a reference for configuration options and documents how to use configuration files.</li> <li>Added an \"Alternatives\" page to the documentation that documents alternative tools.</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Changed reprexlite to use a pyproject.toml-based build process and metadata declaration.</li> <li>Renamed <code>HISTORY.md</code> to <code>CHANGELOG.md</code>.</li> </ul>"},{"location":"changelog/#v100a1-2025-02-11","title":"v1.0.0a1 (2025-02-11)","text":"<p>This is an early version of the 1.0.0 changes that has been available on the main branch of the repository since February 2023. It is being released as a pre-release version in case anyone wants to continue using it. Further significant changes are planned for the final 1.0.0 release.</p> <p>For the release notes for this version, see here.</p>"},{"location":"changelog/#v050-2020-02-20","title":"v0.5.0 (2020-02-20)","text":"<ul> <li>Added experimental IPython interactive editor which can be launched via command line with <code>reprex --ipython</code>. This modified IPython editor will run every cell automatically as a reprex.</li> </ul>"},{"location":"changelog/#v043-2021-11-05","title":"v0.4.3 (2021-11-05)","text":"<ul> <li>Added explicit setting of code evaluation namespace's <code>__name__</code> to <code>'__reprex__'</code>. Previously this was unset and would get inferred, and weird things like <code>'builtins'</code> would turn up. (PR #44)</li> </ul>"},{"location":"changelog/#v042-2021-02-28","title":"v0.4.2 (2021-02-28)","text":"<ul> <li>Added support for parsing code copied from an interactive Python shell (REPL) with <code>&gt;&gt;&gt;</code> prompts. (#29)</li> <li>Fixed issue where <code>tests</code> module was unintentionally included in distribution. (#30)</li> <li>Fixed missing requirement <code>importlib_metadata</code> for Python 3.6 and 3.7. (#31)</li> </ul>"},{"location":"changelog/#v041-2021-02-27","title":"v0.4.1 (2021-02-27)","text":"<ul> <li>Added missing LICENSE file.</li> </ul>"},{"location":"changelog/#v040-2021-02-27","title":"v0.4.0 (2021-02-27)","text":"<ul> <li>Added optional IPython extension that enables <code>%%reprex</code> cell magic. See documentation for usage. (#21)</li> </ul>"},{"location":"changelog/#v031-2021-02-26","title":"v0.3.1 (2021-02-26)","text":"<ul> <li>Documentation improvements. (#14, #19)</li> </ul>"},{"location":"changelog/#v030-2021-02-25","title":"v0.3.0 (2021-02-25)","text":"<ul> <li>Changed pygments styling to use the \"friendly\" color scheme, which looks better for dark backgrounds. (#15)</li> <li>Changed submodule organization for code related to reprex formatting. This is now in the <code>formatting</code> submodule. (#17)</li> </ul>"},{"location":"changelog/#v020-2021-02-20","title":"v0.2.0 (2021-02-20)","text":"<ul> <li>Removing old results from inputs: (#8)<ul> <li>Changed reprexes to\u2014by default\u2014remove lines matching the <code>comment</code> prefix (<code>#&gt;</code> by default). This means that if your input code is a previously rendered reprex, the old results will be removed first and you effectively regenerate it.</li> <li>Added a new option <code>old_results</code> that\u2014if set to True\u2014will preserve such lines.</li> </ul> </li> <li>Fixed a bug that caused intentional blank lines to be removed. (#7)</li> <li>Added stdout capturing. Any content printed to stdout will be shown as a result in the reprex. (#10)</li> <li>Added exception handling and stacktrace capture. If the input code has an exception, the stacktrace will be shown as a result in the reprex. (#12)</li> </ul>"},{"location":"changelog/#v010-2021-02-15","title":"v0.1.0 (2021-02-15)","text":"<p>Initial release! \ud83c\udf89</p>"},{"location":"cli/","title":"CLI Help Documentation","text":"<pre><code>reprex --help\n</code></pre> <pre><code>Usage: reprex COMMAND [OPTIONS]\n\nRender reproducible examples of Python code for sharing. Your code will be      \nexecuted and, in the default output style, the results will be embedded as      \ncomments below their associated lines.                                          \n\nBy default, your system's default command-line text editor will open for you to \ntype or paste in your code. This editor can be changed by setting either of the \nVISUAL or EDITOR environment variables, or by explicitly passing in the --editor\nprogram. The interactive IPython editor requires IPython to be installed. You   \ncan also instead specify an input file with the --infile / -i option.           \n\nAdditional markup will be added that is appropriate to the choice of venue      \nformatting. For example, for the default 'gh' venue for GitHub Flavored         \nMarkdown, the final reprex output will look like:                               \n\n\n ```python                                                                      \n arr = [1, 2, 3, 4, 5]                                                          \n [x + 1 for x in arr]                                                           \n #&gt; [2, 3, 4, 5, 6]                                                             \n max(arr) - min(arr)                                                            \n #&gt; 4                                                                           \n ```                                                                            \n\n &lt;sup&gt;Created at 2021-02-27 00:13 PST by                                        \n [reprexlite](https://github.com/jayqi/reprexlite) v1.0.0&lt;/sup&gt;                 \n\n\nThe supported venue formats are:                                                \n\n \u2022 gh : Github Flavored Markdown                                                \n \u2022 so : StackOverflow (alias for 'gh')                                          \n \u2022 ds : Discourse (alias for 'gh')                                              \n \u2022 html : HTML                                                                  \n \u2022 py : Python script                                                           \n \u2022 rtf : Rich Text Format                                                       \n \u2022 slack : Slack                                                                \n\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help -h  Display this message and exit.                                    \u2502\n\u2502 --version  Display application version.                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Parameters \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --infile                    -i  Read code from this file instead of opening  \u2502\n\u2502                                 an editor.                                   \u2502\n\u2502 --outfile                   -o  Write rendered reprex to this file instead   \u2502\n\u2502                                 of standard out.                             \u2502\n\u2502 --editor                    -e  Command-line program name of editor to use.  \u2502\n\u2502                                 If not specified, check $EDITOR and $VISUAL  \u2502\n\u2502                                 environment variables. If 'ipython', will    \u2502\n\u2502                                 launch the IPython interactive editor.       \u2502\n\u2502 --venue                     -v  Key to identify the output venue that the    \u2502\n\u2502                                 reprex will be shared in. Used to select an  \u2502\n\u2502                                 appropriate formatter. See \"Venues           \u2502\n\u2502                                 Formatting\" documentation for formats        \u2502\n\u2502                                 included with reprexlite. [choices: gh, ds,  \u2502\n\u2502                                 so, html, py, rtf, slack] [default: gh]      \u2502\n\u2502 --advertise --no-advertise      Whether to include a footer that credits     \u2502\n\u2502                                 reprexlite. If unspecified, will depend on   \u2502\n\u2502                                 specified venue formatter's default.         \u2502\n\u2502 --session-info                  Include details about session and            \u2502\n\u2502   --no-session-info             environment that the reprex was generated    \u2502\n\u2502                                 with. [default: False]                       \u2502\n\u2502 --style --no-style              Whether to autoformat code with black.       \u2502\n\u2502                                 Requires black to be installed. [default:    \u2502\n\u2502                                 False]                                       \u2502\n\u2502 --prompt                        Prefix to use as primary prompt for code     \u2502\n\u2502                                 lines. [default: ]                           \u2502\n\u2502 --continuation                  Prefix to use as secondary prompt for        \u2502\n\u2502                                 continued code lines. [default: ]            \u2502\n\u2502 --comment                       Prefix to use for results returned by        \u2502\n\u2502                                 expressions. [default: #&gt;]                   \u2502\n\u2502 --keep-old-results              Whether to additionally include results of   \u2502\n\u2502   --no-keep-old-results         expressions detected in the original input   \u2502\n\u2502                                 when formatting the reprex output. [default: \u2502\n\u2502                                 False]                                       \u2502\n\u2502 --parsing-method                Method for parsing input. 'auto' will        \u2502\n\u2502                                 automatically detect either default          \u2502\n\u2502                                 reprex-style input or standard doctest-style \u2502\n\u2502                                 input. 'declared' will allow you to specify  \u2502\n\u2502                                 custom line prefixes. Values for 'prompt',   \u2502\n\u2502                                 'continuation', and 'comment' will be used   \u2502\n\u2502                                 for both output formatting and input         \u2502\n\u2502                                 parsing, unless the associated 'input_*'     \u2502\n\u2502                                 override settings are supplied. [choices:    \u2502\n\u2502                                 auto, declared] [default: auto]              \u2502\n\u2502 --input-prompt                  Prefix to use as primary prompt for code     \u2502\n\u2502                                 lines when parsing input. Only used if       \u2502\n\u2502                                 'parsing_method' is 'declared'. If not set,  \u2502\n\u2502                                 'prompt' is used for both input parsing and  \u2502\n\u2502                                 output formatting.                           \u2502\n\u2502 --input-continuation            Prefix to use as secondary prompt for        \u2502\n\u2502                                 continued code lines when parsing input.     \u2502\n\u2502                                 Only used if 'parsing_method' is 'declared'. \u2502\n\u2502                                 If not set, 'prompt' is used for both input  \u2502\n\u2502                                 parsing and output formatting.               \u2502\n\u2502 --input-comment                 Prefix to use for results returned by        \u2502\n\u2502                                 expressions when parsing input. Only used if \u2502\n\u2502                                 'parsing_method' is 'declared'. If not set,  \u2502\n\u2502                                 'prompt' is used for both input parsing and  \u2502\n\u2502                                 output formatting.                           \u2502\n\u2502 --verbose                       Increase verbosity.                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":"<p>reprexlite has the following configuration options.</p> <p>Note</p> <p>Command-line option names for these configuration variables use hyphens instead of underscores.</p> Name Type Description <code>editor</code> <code>Optional[str]</code> Command-line program name of editor to use. If not specified, check $EDITOR and $VISUAL environment variables. If 'ipython', will launch the IPython interactive editor. <code>venue</code> <code>reprexlite.config.Venue</code> Key to identify the output venue that the reprex will be shared in. Used to select an appropriate formatter. See \"Venues Formatting\" documentation for formats included with reprexlite. <code>advertise</code> <code>Optional[bool]</code> Whether to include a footer that credits reprexlite. If unspecified, will depend on specified venue formatter's default. <code>session_info</code> <code>bool</code> Include details about session and environment that the reprex was generated with. <code>style</code> <code>bool</code> Whether to autoformat code with black. Requires black to be installed. <code>prompt</code> <code>str</code> Prefix to use as primary prompt for code lines. <code>continuation</code> <code>str</code> Prefix to use as secondary prompt for continued code lines. <code>comment</code> <code>str</code> Prefix to use for results returned by expressions. <code>keep_old_results</code> <code>bool</code> Whether to additionally include results of expressions detected in the original input when formatting the reprex output. <code>parsing_method</code> <code>reprexlite.config.ParsingMethod</code> Method for parsing input. 'auto' will automatically detect either default reprex-style input or standard doctest-style input. 'declared' will allow you to specify custom line prefixes. Values for 'prompt', 'continuation', and 'comment' will be used for both output formatting and input parsing, unless the associated 'input_*' override settings are supplied. <code>input_prompt</code> <code>Optional[str]</code> Prefix to use as primary prompt for code lines when parsing input. Only used if 'parsing_method' is 'declared'. If not set, 'prompt' is used for both input parsing and output formatting. <code>input_continuation</code> <code>Optional[str]</code> Prefix to use as secondary prompt for continued code lines when parsing input. Only used if 'parsing_method' is 'declared'. If not set, 'prompt' is used for both input parsing and output formatting. <code>input_comment</code> <code>Optional[str]</code> Prefix to use for results returned by expressions when parsing input. Only used if 'parsing_method' is 'declared'. If not set, 'prompt' is used for both input parsing and output formatting."},{"location":"configuration/#configuration-files","title":"Configuration files","text":"<p>reprexlite supports reading default configuration values from configuration files. Both project-level files and user-level files are supported.</p>"},{"location":"configuration/#pyprojecttoml","title":"<code>pyproject.toml</code>","text":"<p>reprexlite will search the nearest <code>pyproject.toml</code> file in the current working directory and any parent directory. Configuration for reprexlite should be in the <code>[tool.reprexlite]</code> table following standard <code>pyproject.toml</code> specifications. For example:</p> <pre><code>[tool.reprexlite]\neditor = \"some_editor\"\n</code></pre>"},{"location":"configuration/#reprexlitetoml-or-reprexlitetoml","title":"<code>reprexlite.toml</code> or <code>.reprexlite.toml</code>","text":"<p>reprexlite also supports files named <code>reprexlite.toml</code> or <code>.reprexlite.toml</code> for project-level configuration. It will also search for these in the current working directory or any parent directory.</p> <p>For reprexlite-specific files, all configuration options should be declared in the root namespace.</p> <pre><code>editor = \"some_editor\"\n</code></pre>"},{"location":"configuration/#user-level-configuration","title":"User-level configuration","text":"<p>reprexlite supports searching standard platform-specific user configuration directories as determined by platformdirs. Here are typical locations depending on platform:</p> Platform Path Linux <code>~/.config/reprexlite/config.toml</code> MacOS <code>~/Library/Application Support/reprexlite/config.toml</code> Windows <code>C:\\Users\\&lt;username&gt;\\AppData\\Local\\reprexlite\\config.toml</code> <p>You can check where your user configuration would be with</p> <pre><code>python -m platformdirs\n</code></pre> <p>Look for the section <code>-- app dirs (without optional 'version')</code> for the value of <code>user_config_dir</code>. The value for <code>MyApp</code> is <code>reprexlite</code>. The configuration file should be named <code>config.toml</code> inside that directory.</p>"},{"location":"design-philosophy/","title":"Design Philosophy","text":"<p>Reprex is a portmanteau for reproducible example. This term and its associated approach to minimal reproducible examples have been popularized within the R data science community, driven by the adoption of the reprex tidyverse package.</p> <p>The reprex code:</p> <ul> <li>Must run and, therefore, should be run by the person posting. No faking it.</li> <li>Should be easy for others to digest, so they don\u2019t necessarily have to run it. You are encouraged to include selected bits of output.</li> <li>Should be easy for others to copy + paste + run, if and only if they so choose. Don\u2019t let inclusion of output break executability.</li> </ul> <p><p>\u2015 \"Package Philosophy,\" from the R reprex documentation</p></p> <p>Writing a good reprex takes thought and effort (see \"Reprex Do's and Don'ts\" for tips). The goal of reprexlite is to be a tool for Python that handles the mechanical stuff\u2014running your code, capturing the output, formatting everything\u2014so you don't have to worry about it, and you can devote your full attention to the important, creative work of writing the content. The action of running your code and seeing the outputs can also be a helpful forcing function in really making sure your example works and produces what you intend.</p>"},{"location":"design-philosophy/#why-reproducible-examples","title":"Why reproducible examples?","text":"<p>From the R reprex readme.</p>"},{"location":"design-philosophy/#if-youre-looking-for-help-with-a-problem-or-bug","title":"If you're looking for help with a problem or bug...","text":"<p>...you are more likely to succeed if you make it as easy as possible for others to help you. You are asking people to do work on your behalf. Remember: most open-source software maintainers and StackOverflow posters are volunteers and are not obligated to help you. Even someone who is obligated to help you would still be able to get to an answer more quickly if you make it easier for them to understand your problem.</p> <p>Plus, the exercise of writing the reprex might even help you figure out how to solve the problem yourself. This is basically the principle of rubber duck debugging.</p>"},{"location":"design-philosophy/#if-youre-writing-a-tutorial-or-documentation","title":"If you're writing a tutorial or documentation...","text":"<p>...actual working examples are valuable to your users. A reprex\u2014with complete directly runnable code and showing the expected outputs\u2014will show your audience what you're demonstrating, and also give them the option to easily try for themselves. Doing is often the most effective way of learning how to do something in code. And, with documentation especially, people often just want to arrive at working code for their use case as quickly as possible. Something that they can just copy and run is exactly what they're looking for.</p>"},{"location":"design-philosophy/#reprex-vs-copying-from-shell-doctest-style","title":"Reprex vs. Copying from shell (doctest-style)","text":"<p>A widely used approach for Python code examples is copying from an interactive Python shell. It is easily recognized from the <code>&gt;&gt;&gt;</code> prompt before each code statement. Such a code example is sometimes called a \"doctest\" because the <code>doctest</code> module from the Python standard library is able to parse it.</p> <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.sqrt(4)\n2.0\n</code></pre> <p>This style of code example takes no special tools to generate: simply open a <code>python</code> shell from command line, write your code, and copy what you see. Many Python packages use it for their documentation, e.g., requests. There is also tooling for parsing it. The doctest module can run such examples in the docstrings of your scripts, and test that the output matches what is written. Other tools like Sphinx are able to parse it when rendering your documentation into other formats.</p> <p>The drawback of doctest-style examples is that they are not valid Python syntax, so you can't always just copy, paste, and run such examples. The <code>&gt;&gt;&gt;</code> prompt is not valid. While IPython's interactive shell and Jupyter notebooks do support executing code with the prompt, it won't work in a regular Python REPL or in Python scripts. Furthermore, since the outputs might be anything, they may not be valid Python syntax either, depending on their <code>repr</code>. A barebones class, for example, will look like <code>&lt;__main__.MyClass object at 0x7f932a001400&gt;</code> and is not valid.</p> <p>So, while no special tools were needed to generate a doctest-style example, either special tools or manual editing are needed to run it. This puts the burden on the person you're sharing with, which is counterproductive. As discussed in the previous section, we want reproducible examples to make it easier for others to run your code.</p> <p>In contrast, reprexes are valid Python code. Anyone can copy, paste, and run a reprex without any special tools or manual editing required.</p> <pre><code>import math\nmath.sqrt(4)\n#&gt; 2.0\n</code></pre> <p>If this has convinced you, you can take advantage of reprexlite's ability to parse doctest-style code and easily convert those examples to reprexes instead.</p>"},{"location":"design-philosophy/#reprexlites-design","title":"reprexlite's Design","text":"<p>The primary design goal of reprexlite is that it should be quick and convenient to use. That objective drove the emphasis on following the design characteristics:</p> <ul> <li>Lightweight. reprexlite needs to be in your virtual environment to be able to run your code. By having minimal and lightweight dependencies itself, reprexlite is quick to install and is unlikely to conflict with your other dependencies. Any advanced functionality that require heavier dependencies are optional.</li> <li>Easy access. reprexlite comes with a CLI, so you can quickly create a reprex without needing to start a Python shell or to import anything.<ul> <li>And flexible. The CLI isn't the only option. The Python library provides programmatic access, and there is an optional IPython/Jupyter extension for use with a cell magic.</li> </ul> </li> </ul> <p>The API, including the available configuration and naming of parameters, mostly matches both R reprex and reprexpy. The intent is that anyone familiar with these other tools can quickly feel comfortable with reprexlite.</p> <p>As a secondary objective, the reprexlite library is designed so that its underlying functionality is accessible and extensible. It has a modular object-oriented design based on composition. Individual parts, like the code parsing or the output formatting, can be used independently, extended, or replaced. Additionally, the library is thoroughly type-annotated and documented.</p>"},{"location":"design-philosophy/#limitations","title":"Limitations","text":"<p>Compared to R reprex and reprexpy, reprexlite does trade off some capabilities in favor of our design objective. Known limitations include:</p> <ul> <li>No clipboard integration. The two main Python clipboard libraries, pyperclip and xerox, have non-Python dependencies on some OSes that make them sometimes difficult to install. However, command-line editor support built-in to the CLI is nearly as easy as reading from clipboard, and has the added benefit that you can see the code before it gets executed.</li> <li>No plot image support. Both R reprex and reprexpy support automatically uploading plots to imgur.com and injecting the link into your outputted reprex. This always seemed to me like a weird default as it could lead to inadvertent leaking of private data.</li> <li>Code is not run in a subprocess, so it's not perfectly isolated. reprexlite runs the code using <code>eval</code> and <code>exec</code> with a fresh namespace, but otherwise still executes code within the main Python process. That means, for example, modules that are stateful or have been monkeypatched could potentially leak that state into the reprex.</li> </ul> <p>By not supporting the first two functionalities, reprexlite has significantly fewer and simpler dependencies. Both of these features, while convenient, could lead to unintentional code execution or leaking data to the public web. From that perspective, I believe this is a worthwhile tradeoff.</p> <p>The third limitation is one where feedback is welcome. Hopefully it will only matter in unusual edge cases. If you have ideas for mitigation for the current <code>eval</code>-<code>exec</code> implementation, please open an issue on GitHub. A subprocess-based implementation would solve this, but would be more difficult to capture output from\u2014any implementation ideas for this approach are also welcome.</p>"},{"location":"dos-and-donts/","title":"Reprex Do's and Don'ts","text":"<p>This article discusses how to write an effective reprex. If you're asking for help or sharing code with someone, you will be much more likely to succeed if you have a good reprex. If you still need to be convinced why you should write a reprex or use reprexlite, check out the first half of \"Design Philosophy\".</p> <p>Writing a good reprex takes thought and effort. A tool like reprexlite is not a magic bullet\u2014it's meant to take care of the mechanical stuff so you can devote your energy towards coming up with the right content.</p> <p>Many of the key ideas in this article are borrowed from R reprex's \"Reprex do's and don'ts\" and StackOverflow's \"How to create a Minimal, Reproducible Example\".</p>"},{"location":"dos-and-donts/#your-reprexes-should-be","title":"Your reprexes should be...","text":""},{"location":"dos-and-donts/#minimal","title":"Minimal","text":"<ul> <li>Do use the smallest, simplest data possible.<ul> <li>If you need a dataframe, the <code>sklearn.datasets</code> module has convenient toy datasets like <code>iris</code>.</li> <li>The Faker library has utilities to help you generate fake data like names and addresses.</li> </ul> </li> <li>Don't include code unrelated to the specific thing you want to demonstrate.<ul> <li>Do ruthlessly remove unnecessary code. If you're not sure, try removing things bit by bit until it doesn't produce what you want anymore.</li> <li>Consider starting your reprex from scratch. This helps force you to add in only what is needed.</li> </ul> </li> </ul>"},{"location":"dos-and-donts/#readable","title":"Readable","text":"<ul> <li>Do follow code style best practices.<ul> <li>Consider using the <code>style</code> option which will use black to autoformat your code.</li> </ul> </li> <li>Don't sacrifice clarity for brevity.<ul> <li>Don't play code golf. For loops and if-else blocks can often be more readable.</li> <li>Do use clear, descriptive, and idiomatic naming conventions.</li> </ul> </li> </ul>"},{"location":"dos-and-donts/#reproducible","title":"Reproducible","text":"<ul> <li>Do include everything required to produce your example, including imports and custom class/function definitions. If you're using reprexlite, your code won't work without this anyways.</li> <li>Do detail what versions of relevant package, Python, and OS you are using.<ul> <li>Consider using the <code>session_info</code> option, which will include information about your Python, OS, and installed packages at the end of your reprex.</li> </ul> </li> <li>Do double-check that your example reproduces the thing you want to show. One can often inadvertently solve a problem they were trying to debug when writing an example.</li> <li>Don't hardcode paths that wouldn't exist on someone else's computer, especially absolute paths.</li> </ul>"},{"location":"dos-and-donts/#respectful-of-other-peoples-computers","title":"Respectful of other people's computers","text":"<ul> <li>Do clean up after yourself if you create files. Take advantage of Python's <code>tempfile</code> module for creating temporary files and directories.</li> <li>Don't delete files that you didn't create.</li> </ul>"},{"location":"dos-and-donts/#this-seems-like-a-lot-of-work","title":"This seems like a lot of work!","text":"<p>Yes, creating a great reprex requires work. You are asking other people to do work too. It\u2019s a partnership.</p> <p>80% of the time you will solve your own problem in the course of writing an excellent reprex. YMMV.</p> <p>The remaining 20% of the time, you will create a reprex that is more likely to elicit the desired behavior in others.</p> <p><p>\u2015 \"Reprex do's and don'ts,\" from the R reprex documentation</p></p>"},{"location":"ipython-jupyter-magic/","title":"IPython/Jupyter Magic","text":"<p>Reprex-rendering is also available in IPython, Jupyter, and VS Code through an IPython cell magic. This functionality requires IPython to be installed at a minimum. (You can install both reprexlite and IPython together with <code>reprexlite[ipython]</code>.)</p> <p>To use, first load the extension:</p> In\u00a0[1]: Copied! <pre>%load_ext reprexlite\n</pre> %load_ext reprexlite <p>and then simply use the <code>%%reprex</code> magic with a cell containing the code you want a reprex of.</p> In\u00a0[2]: Copied! <pre>%%reprex\n\nfrom itertools import product\n\ngrid = list(product([1, 2, 3], [8, 16]))\ngrid\nlist(zip(*grid))\n</pre> %%reprex  from itertools import product  grid = list(product([1, 2, 3], [8, 16])) grid list(zip(*grid)) <pre>```python\nfrom itertools import product\n\ngrid = list(product([1, 2, 3], [8, 16]))\ngrid\n#&gt; [(1, 8), (1, 16), (2, 8), (2, 16), (3, 8), (3, 16)]\nlist(zip(*grid))\n#&gt; [(1, 1, 2, 2, 3, 3), (8, 16, 8, 16, 8, 16)]\n```\n\n&lt;sup&gt;Created at 2021-02-27 16:08:34 PST by [reprexlite](https://github.com/jayqi/reprexlite) v0.3.1&lt;/sup&gt;\n\n</pre> <p>That's it! The cell magic shares the same interface and command-line options as the CLI.</p> In\u00a0[3]: Copied! <pre>%%reprex -v slack\nx = 2\nx + 2\n</pre> %%reprex -v slack x = 2 x + 2 <pre>```\nx = 2\nx + 2\n#&gt; 4\n```\n\n</pre> In\u00a0[4]: Copied! <pre>%reprex\n</pre> %reprex <pre>reprexlite v0.3.1 IPython Magic\n\nCell Magic Usage: %%reprex [OPTIONS]\n\n  Render reproducible examples of Python code for sharing. Your code will be\n  executed and the results will be embedded as comments below their associated\n  lines.\n\n  Additional markup will be added that is appropriate to the choice of venue\n  option. For example, for the default `gh` venue for GitHub Flavored\n  Markdown, the final reprex will look like:\n\n  ----------------------------------------\n  ```python\n  arr = [1, 2, 3, 4, 5]\n  [x + 1 for x in arr]\n  #&gt; [2, 3, 4, 5, 6]\n  max(arr) - min(arr)\n  #&gt; 4\n  ```\n \n  &lt;sup&gt;Created at 2021-02-27 00:13:55 PST by [reprexlite](https://github.com/jayqi/reprexlite) v0.3.1&lt;/sup&gt;\n  ----------------------------------------\n\n  The supported venue formats are:\n \n  - gh : GitHub Flavored Markdown\n  - so : StackOverflow, alias for gh\n  - ds : Discourse, alias for gh\n  - html : HTML\n  - py : Python script\n  - rtf : Rich Text Format\n  - slack : Slack\n\nOptions:\n  -i, --infile PATH               Read code from an input file instead via\n                                  editor.\n\n  -o, --outfile PATH              Write output to file instead of printing to\n                                  console.\n\n  -v, --venue [gh|so|ds|html|py|rtf|slack]\n                                  Output format appropriate to the venue where\n                                  you plan to share this code.  [default: gh]\n\n  --advertise / --no-advertise    Whether to include footer that credits\n                                  reprexlite. If unspecified, will depend on\n                                  specified venue's default.\n\n  --session-info                  Whether to include details about session and\n                                  installed packages.\n\n  --style                         Autoformat code with black. Requires black to\n                                  be installed.\n\n  --comment TEXT                  Comment prefix to use for results returned by\n                                  expressions.  [default: #&gt;]\n\n  --old-results                   Keep old results, i.e., lines that match the\n                                  prefix specified by the --comment option. If\n                                  not using this option, then such lines are\n                                  removed, meaning that an input that is a\n                                  reprex will be effectively regenerated.\n\n</pre> <p>If you're in VS Code and <code>ipykernel</code> is installed, you similarly use the <code>%%reprex</code> cell magic with Python Interactive windows. For a file set to Python language mode, use <code># %%</code> to mark an IPython cell that can then be run. Or you can open the Interactive window on its own via \"Jupyter: Create Interactive Window\" through the Command Palette. See VS Code docs for more info.</p> <p>Note that\u2014just like other ways of rendering a reprex\u2014your code is evaluated in an isolated namespace that is separate from the namespace of your IPython session or your notebook. That means, for example, variables defined in your notebook won't exist in your reprex.</p> In\u00a0[5]: Copied! <pre>notebook_var = 2\n</pre> notebook_var = 2 In\u00a0[6]: Copied! <pre>%%reprex --no-advertise\n\nnotebook_var\n</pre> %%reprex --no-advertise  notebook_var <pre>```python\nnotebook_var\n#&gt; Traceback (most recent call last):\n#&gt;   File \"/Users/jqi/repos/reprexlite/reprexlite/code.py\", line 69, in evaluate\n#&gt;     result = eval(str(self).strip(), scope, scope)\n#&gt;   File \"&lt;string&gt;\", line 1, in &lt;module&gt;\n#&gt; NameError: name 'notebook_var' is not defined\n```\n\n</pre>"},{"location":"ipython-jupyter-magic/#ipythonjupyter-magic","title":"IPython/Jupyter Magic\u00b6","text":""},{"location":"ipython-jupyter-magic/#print-help-documentation","title":"Print Help Documentation\u00b6","text":"<p>You can use the <code>%reprex</code> line magic (single-<code>%</code>) to print out documentation.</p>"},{"location":"ipython-jupyter-magic/#vs-code-interactive-python-windows","title":"VS Code Interactive Python Windows\u00b6","text":""},{"location":"ipython-jupyter-magic/#isolated-namespace","title":"Isolated Namespace\u00b6","text":""},{"location":"ipython-jupyter-magic/#also-check-out-the-ipython-shell-editor","title":"Also check out the IPython shell editor\u00b6","text":"<p>reprexlite also supports an IPython interactive shell editor. This has the same requirements as using the cell magic (IPython is installed). To use it, simply call use the <code>reprex</code> CLI with:</p> <pre>reprex -e ipython\n</pre> <p>This will launch a special IPython interactive shell where all cells are piped through reprexlite for execution. It's like the cell magic, but without needing to specify any magics!</p>"},{"location":"rendering-and-output-venues/","title":"Rendering and Output Venues","text":"<p>A rendered reprex will be code plus the computed outputs plus additional formatting markup appropriate for some particular output venue. For example, the <code>gh</code> venue (GitHub) will be in GitHub-flavored markdown and may look like this:</p> <pre><code>```python\n2+2\n#&gt; 4\n```\n</code></pre> <p>The venue can be set using the <code>--venue / -v</code> command-line flag or the <code>venue</code> configuration file option. The following section documents the available output venue options.</p>"},{"location":"rendering-and-output-venues/#venue-options","title":"Venue options","text":"Venue Keyword Description Formatter Function <code>gh</code> Github Flavored Markdown <code>format_as_markdown</code> <code>so</code> StackOverflow (alias for 'gh') <code>format_as_markdown</code> <code>ds</code> Discourse (alias for 'gh') <code>format_as_markdown</code> <code>html</code> HTML <code>format_as_html</code> <code>py</code> Python script <code>format_as_python_script</code> <code>rtf</code> Rich Text Format <code>format_as_rtf</code> <code>slack</code> Slack <code>format_for_slack</code>"},{"location":"rendering-and-output-venues/#formatter-functions","title":"Formatter functions","text":""},{"location":"rendering-and-output-venues/#format_as_markdown","title":"<code>format_as_markdown</code>","text":"<p>Format a rendered reprex reprex as a GitHub-Flavored Markdown code block. By default, includes a footer that credits reprexlite.</p> <p>Used for venues: <code>gh</code>, <code>so</code>, <code>ds</code></p> <p>Example</p> <pre><code>```python\n2+2\n#&gt; 4\n```\n</code></pre> <p><sup>\u21b3 API documentation</sup></p>"},{"location":"rendering-and-output-venues/#format_as_html","title":"<code>format_as_html</code>","text":"<p>Format a rendered reprex reprex as an HTML code block. If optional dependency Pygments is available, the rendered HTML will have syntax highlighting for the Python code. By default, includes a footer that credits reprexlite.</p> <p>Used for venues: <code>html</code></p> <p>Example</p> <pre><code>&lt;pre&gt;&lt;code&gt;2+2\n#&gt; 4&lt;/code&gt;&lt;/pre&gt;\n</code></pre> <p><sup>\u21b3 API documentation</sup></p>"},{"location":"rendering-and-output-venues/#format_as_python_script","title":"<code>format_as_python_script</code>","text":"<p>Format a rendered reprex reprex as a Python script.</p> <p>Used for venues: <code>py</code></p> <p>Example</p> <pre><code>2+2\n#&gt; 4\n</code></pre> <p><sup>\u21b3 API documentation</sup></p>"},{"location":"rendering-and-output-venues/#format_as_rtf","title":"<code>format_as_rtf</code>","text":"<p>Format a rendered reprex reprex as a Rich Text Format (RTF) document. Requires dependency Pygments.</p> <p><sup>\u21b3 API documentation</sup></p>"},{"location":"rendering-and-output-venues/#format_for_slack","title":"<code>format_for_slack</code>","text":"<p>Format a rendered reprex as Slack markup.</p> <p>Used for venues: <code>slack</code></p> <p>Example</p> <pre><code>```\n2+2\n#&gt; 4\n```\n</code></pre> <p><sup>\u21b3 API documentation</sup></p>"},{"location":"rendering-and-output-venues/#under-the-hood-and-python-api","title":"Under the hood and Python API","text":"<p>There are two steps to rendering a reprex:</p> <ol> <li>The <code>Reprex.render()</code> method renders a reprex instance as just the code and outputs.</li> <li>A formatter function from <code>reprexlite.formatting</code> (see above) formats the rendered reprex code and outputs for the specified venue.</li> </ol> <p>The whole process is encapsulated in the <code>Reprex.render_and_format()</code> method.</p>"},{"location":"api-reference/config/","title":"reprexlite.config","text":""},{"location":"api-reference/config/#reprexlite.config-classes","title":"Classes","text":""},{"location":"api-reference/config/#reprexlite.config.ParsingMethod","title":"ParsingMethod","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Methods for parsing input strings.</p> <p>Attributes:</p> Name Type Description <code>AUTO</code> <code>str</code> <p>Automatically identify reprex-style or doctest-style input.</p> <code>DECLARED</code> <code>str</code> <p>Use configured values for parsing.</p>"},{"location":"api-reference/config/#reprexlite.config.ReprexConfig","title":"ReprexConfig  <code>dataclass</code>","text":"<pre><code>ReprexConfig(\n    editor: Annotated[\n        Optional[str], Parameter(name=(--editor, -e))\n    ] = None,\n    venue: Annotated[\n        Venue, Parameter(name=(--venue, -v))\n    ] = Venue.GH,\n    advertise: Optional[bool] = None,\n    session_info: bool = False,\n    style: bool = False,\n    prompt: str = \"\",\n    continuation: str = \"\",\n    comment: str = \"#&gt;\",\n    keep_old_results: bool = False,\n    parsing_method: ParsingMethod = ParsingMethod.AUTO,\n    input_prompt: Optional[str] = None,\n    input_continuation: Optional[str] = None,\n    input_comment: Optional[str] = None,\n)\n</code></pre> <p>Configuration dataclass for reprexlite. Used to configure input parsing and output formatting.</p> <p>Parameters:</p> Name Type Description Default <code>editor</code> <code>Optional[str]</code> <p>Command-line program name of editor to use. If not specified, check $EDITOR and $VISUAL environment variables. If 'ipython', will launch the IPython interactive editor.</p> <code>None</code> <code>venue</code> <code>str</code> <p>Key to identify the output venue that the reprex will be shared in. Used to select an appropriate formatter. See \"Venues Formatting\" documentation for formats included with reprexlite.</p> <code>GH</code> <code>advertise</code> <code>bool</code> <p>Whether to include a footer that credits reprexlite. If unspecified, will depend on specified venue formatter's default.</p> <code>None</code> <code>session_info</code> <code>bool</code> <p>Include details about session and environment that the reprex was generated with.</p> <code>False</code> <code>style</code> <code>bool</code> <p>Whether to autoformat code with black. Requires black to be installed.</p> <code>False</code> <code>prompt</code> <code>str</code> <p>Prefix to use as primary prompt for code lines.</p> <code>''</code> <code>continuation</code> <code>str</code> <p>Prefix to use as secondary prompt for continued code lines.</p> <code>''</code> <code>comment</code> <code>str</code> <p>Prefix to use for results returned by expressions.</p> <code>'#&gt;'</code> <code>keep_old_results</code> <code>bool</code> <p>Whether to additionally include results of expressions detected in the original input when formatting the reprex output.</p> <code>False</code> <code>parsing_method</code> <code>str</code> <p>Method for parsing input. 'auto' will automatically detect either default reprex-style input or standard doctest-style input. 'declared' will allow you to specify custom line prefixes. Values for 'prompt', 'continuation', and 'comment' will be used for both output formatting and input parsing, unless the associated 'input_*' override settings are supplied.</p> <code>AUTO</code> <code>input_prompt</code> <code>str</code> <p>Prefix to use as primary prompt for code lines when parsing input. Only used if 'parsing_method' is 'declared'. If not set, 'prompt' is used for both input parsing and output formatting.</p> <code>None</code> <code>input_continuation</code> <code>str</code> <p>Prefix to use as secondary prompt for continued code lines when parsing input. Only used if 'parsing_method' is 'declared'. If not set, 'prompt' is used for both input parsing and output formatting.</p> <code>None</code> <code>input_comment</code> <code>str</code> <p>Prefix to use for results returned by expressions when parsing input. Only used if 'parsing_method' is 'declared'. If not set, 'prompt' is used for both input parsing and output formatting.</p> <code>None</code>"},{"location":"api-reference/config/#reprexlite.config.Venue","title":"Venue","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enum for specifying the output venue for a reprex.</p> <p>Attributes:</p> Name Type Description <code>GH</code> <code>str</code> <p>GitHub-flavored Markdown</p> <code>DS</code> <code>str</code> <p>Discourse</p> <code>SO</code> <code>str</code> <p>StackOverflow</p> <code>HTML</code> <code>str</code> <p>HTML</p> <code>PY</code> <code>str</code> <p>Python script</p> <code>RTF</code> <code>str</code> <p>Rich Text Format</p> <code>SLACK</code> <code>str</code> <p>Slack markup</p>"},{"location":"api-reference/exceptions/","title":"reprexlite.exceptions","text":""},{"location":"api-reference/exceptions/#reprexlite.exceptions-classes","title":"Classes","text":""},{"location":"api-reference/exceptions/#reprexlite.exceptions.BlackNotFoundError","title":"BlackNotFoundError","text":"<p>               Bases: <code>ModuleNotFoundError</code>, <code>ReprexliteException</code></p> <p>Raised when ipython cannot be found when using a black-dependent feature.</p>"},{"location":"api-reference/exceptions/#reprexlite.exceptions.EditorError","title":"EditorError","text":"<p>               Bases: <code>ReprexliteException</code></p> <p>Raised when an error occurs with the editor.</p>"},{"location":"api-reference/exceptions/#reprexlite.exceptions.IPythonNotFoundError","title":"IPythonNotFoundError","text":"<p>               Bases: <code>ModuleNotFoundError</code>, <code>ReprexliteException</code></p> <p>Raised when ipython cannot be found when using an IPython-dependent feature.</p>"},{"location":"api-reference/exceptions/#reprexlite.exceptions.InputSyntaxError","title":"InputSyntaxError","text":"<p>               Bases: <code>SyntaxError</code>, <code>ReprexliteException</code></p> <p>Raised when encountering a syntax error when parsing input.</p>"},{"location":"api-reference/exceptions/#reprexlite.exceptions.PygmentsNotFoundError","title":"PygmentsNotFoundError","text":"<p>               Bases: <code>ModuleNotFoundError</code>, <code>ReprexliteException</code></p> <p>Raised when pygments cannot be found when using a pygments-dependent feature.</p>"},{"location":"api-reference/exceptions/#reprexlite.exceptions.ReprexliteException","title":"ReprexliteException","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for reprexlite exceptions.</p>"},{"location":"api-reference/exceptions/#reprexlite.exceptions.UnexpectedError","title":"UnexpectedError","text":"<pre><code>UnexpectedError(msg: str, *args: object)\n</code></pre> <p>               Bases: <code>ReprexliteException</code></p> <p>Raised when an unexpected case happens.</p> Source code in <code>reprexlite/exceptions.py</code> <pre><code>def __init__(self, msg: str, *args: object):\n    if not msg.endswith(\" \"):\n        msg += \" \"\n    msg += (\n        \"If you see this error from normal usage, please report at \"\n        \"https://github.com/jayqi/reprexlite/issues\"\n    )\n    super().__init__(msg, *args)\n</code></pre>"},{"location":"api-reference/formatting/","title":"reprexlite.formatting","text":""},{"location":"api-reference/formatting/#reprexlite.formatting-classes","title":"Classes","text":""},{"location":"api-reference/formatting/#reprexlite.formatting.Advertisement","title":"Advertisement","text":"<pre><code>Advertisement()\n</code></pre> <p>Class for generating the advertisement note for reprexlite.</p> <p>Attributes:</p> Name Type Description <code>timestamp</code> <code>str</code> <p>Timestamp of instance instantiation</p> <code>version</code> <code>str</code> <p>Version of reprexlite</p> Source code in <code>reprexlite/formatting.py</code> <pre><code>def __init__(self):\n    self.timestamp = datetime.now().astimezone().strftime(\"%Y-%m-%d %H:%M %Z\")\n    self.version = f\"v{__version__}\"\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.Advertisement-functions","title":"Functions","text":""},{"location":"api-reference/formatting/#reprexlite.formatting.Advertisement.code_comment","title":"code_comment","text":"<pre><code>code_comment() -&gt; str\n</code></pre> <p>Render reprexlite advertisement as a comment in Python code.</p> Source code in <code>reprexlite/formatting.py</code> <pre><code>def code_comment(self) -&gt; str:\n    \"\"\"Render reprexlite advertisement as a comment in Python code.\"\"\"\n    return f\"# {self.text()}\"\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.Advertisement.html","title":"html","text":"<pre><code>html() -&gt; str\n</code></pre> <p>Render reprexlite advertisement in HTML.</p> Source code in <code>reprexlite/formatting.py</code> <pre><code>def html(self) -&gt; str:\n    \"\"\"Render reprexlite advertisement in HTML.\"\"\"\n    return (\n        f\"&lt;p&gt;&lt;sup&gt;Created at {self.timestamp} by \"\n        f'&lt;a href=\"{self.url}\"&gt;{self.pkg}&lt;/a&gt; {self.version}&lt;/sup&gt;&lt;/p&gt;'\n    )\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.Advertisement.markdown","title":"markdown","text":"<pre><code>markdown() -&gt; str\n</code></pre> <p>Render reprexlite advertisement in GitHub Flavored Markdown.</p> Source code in <code>reprexlite/formatting.py</code> <pre><code>def markdown(self) -&gt; str:\n    \"\"\"Render reprexlite advertisement in GitHub Flavored Markdown.\"\"\"\n    return f\"&lt;sup&gt;Created at {self.timestamp} by [{self.pkg}]({self.url}) {self.version}&lt;/sup&gt;\"\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.Advertisement.text","title":"text","text":"<pre><code>text() -&gt; str\n</code></pre> <p>Render reprexlite advertisement in plain text.</p> Source code in <code>reprexlite/formatting.py</code> <pre><code>def text(self) -&gt; str:\n    \"\"\"Render reprexlite advertisement in plain text.\"\"\"\n    return f\"Created at {self.timestamp} by {self.pkg} {self.version} &lt;{self.url}&gt;\"\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.FormatterRegistry","title":"FormatterRegistry","text":"<p>Registry of formatters keyed by venue keywords.</p>"},{"location":"api-reference/formatting/#reprexlite.formatting.FormatterRegistry-functions","title":"Functions","text":""},{"location":"api-reference/formatting/#reprexlite.formatting.FormatterRegistry.register","title":"register","text":"<pre><code>register(venue: Venue, label: str)\n</code></pre> <p>Decorator that registers a formatter implementation.</p> <p>Parameters:</p> Name Type Description Default <code>venue</code> <code>str</code> <p>Venue keyword that formatter will be registered to.</p> required <code>label</code> <code>str</code> <p>Short human-readable label explaining the venue.</p> required Source code in <code>reprexlite/formatting.py</code> <pre><code>def register(self, venue: Venue, label: str):\n    \"\"\"Decorator that registers a formatter implementation.\n\n    Args:\n        venue (str): Venue keyword that formatter will be registered to.\n        label (str): Short human-readable label explaining the venue.\n    \"\"\"\n\n    def _register(fn: Formatter):\n        self._registry[Venue(venue)] = FormatterRegistration(fn=fn, label=label)\n        return fn\n\n    return _register\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting-functions","title":"Functions","text":""},{"location":"api-reference/formatting/#reprexlite.formatting.format_as_html","title":"format_as_html","text":"<pre><code>format_as_html(\n    reprex_str: str, config: Optional[ReprexConfig] = None\n) -&gt; str\n</code></pre> <p>Format a rendered reprex reprex as an HTML code block. If optional dependency Pygments is available, the rendered HTML will have syntax highlighting for the Python code. By default, includes a footer that credits reprexlite.</p> <p>Parameters:</p> Name Type Description Default <code>reprex_str</code> <code>str</code> <p>The reprex string to render.</p> required <code>config</code> <code>Optional[ReprexConfig]</code> <p>Configuration for the reprex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The rendered reprex</p> Example <pre><code>2+2\n#&gt; 4</code></pre> Source code in <code>reprexlite/formatting.py</code> <pre><code>@formatter_registry.register(venue=Venue.HTML, label=\"HTML\")\ndef format_as_html(reprex_str: str, config: Optional[ReprexConfig] = None) -&gt; str:\n    \"\"\"Format a rendered reprex reprex as an HTML code block. If optional dependency Pygments is\n    available, the rendered HTML will have syntax highlighting for the Python code. By default,\n    includes a footer that credits reprexlite.\n\n    Args:\n        reprex_str (str): The reprex string to render.\n        config (Optional[ReprexConfig]): Configuration for the reprex. Defaults to None.\n\n    Returns:\n        str: The rendered reprex\n\n    Example:\n        &lt;pre&gt;&lt;code&gt;2+2\n        #&gt; 4&lt;/code&gt;&lt;/pre&gt;\n    \"\"\"\n    if config is None:\n        config = ReprexConfig()\n    advertise = config.advertise if config.advertise is not None else True\n    out = []\n    try:\n        from pygments import highlight\n        from pygments.formatters import HtmlFormatter\n        from pygments.lexers import PythonLexer\n\n        formatter = HtmlFormatter(style=\"friendly\", lineanchors=True, linenos=True, wrapcode=True)\n        out.append(f\"&lt;style&gt;{formatter.get_style_defs('.highlight')}&lt;/style&gt;\")\n        out.append(highlight(str(reprex_str), PythonLexer(), formatter))\n    except ImportError:\n        out.append(f\"&lt;pre&gt;&lt;code&gt;{reprex_str}&lt;/code&gt;&lt;/pre&gt;\")\n\n    if advertise:\n        out.append(Advertisement().html().strip())\n    if config.session_info:\n        out.append(\"&lt;details&gt;&lt;summary&gt;Session Info&lt;/summary&gt;\")\n        out.append(f\"&lt;pre&gt;&lt;code&gt;{SessionInfo()}&lt;/code&gt;&lt;/pre&gt;\")\n        out.append(\"&lt;/details&gt;\")\n    return \"\\n\".join(out) + \"\\n\"\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.format_as_markdown","title":"format_as_markdown","text":"<pre><code>format_as_markdown(\n    reprex_str: str, config: Optional[ReprexConfig] = None\n) -&gt; str\n</code></pre> <p>Format a rendered reprex reprex as a GitHub-Flavored Markdown code block. By default, includes a footer that credits reprexlite.</p> <p>Parameters:</p> Name Type Description Default <code>reprex_str</code> <code>str</code> <p>The reprex string to render.</p> required <code>config</code> <code>Optional[ReprexConfig]</code> <p>Configuration for the reprex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The rendered reprex</p> Example <pre><code>2+2\n#&gt; 4\n</code></pre> Source code in <code>reprexlite/formatting.py</code> <pre><code>@formatter_registry.register(venue=Venue.DS, label=f\"Discourse (alias for '{Venue.GH.value}')\")\n@formatter_registry.register(venue=Venue.SO, label=f\"StackOverflow (alias for '{Venue.GH.value}')\")\n@formatter_registry.register(venue=Venue.GH, label=\"Github Flavored Markdown\")\ndef format_as_markdown(\n    reprex_str: str,\n    config: Optional[ReprexConfig] = None,\n) -&gt; str:\n    \"\"\"\n    Format a rendered reprex reprex as a GitHub-Flavored Markdown code block. By default, includes\n    a footer that credits reprexlite.\n\n    Args:\n        reprex_str (str): The reprex string to render.\n        config (Optional[ReprexConfig]): Configuration for the reprex. Defaults to None.\n\n    Returns:\n        str: The rendered reprex\n\n    Example:\n        ```python\n        2+2\n        #&gt; 4\n        ```\n    \"\"\"\n    if config is None:\n        config = ReprexConfig()\n    advertise = config.advertise if config.advertise is not None else True\n    out = []\n    out.append(\"```python\")\n    out.append(reprex_str)\n    out.append(\"```\")\n    if advertise:\n        out.append(\"\\n\" + Advertisement().markdown())\n    if config.session_info:\n        out.append(\"\\n&lt;details&gt;&lt;summary&gt;Session Info&lt;/summary&gt;\")\n        out.append(\"```text\")\n        out.append(str(SessionInfo()))\n        out.append(\"```\")\n        out.append(\"&lt;/details&gt;\")\n    return \"\\n\".join(out) + \"\\n\"\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.format_as_python_script","title":"format_as_python_script","text":"<pre><code>format_as_python_script(\n    reprex_str: str, config: Optional[ReprexConfig] = None\n) -&gt; str\n</code></pre> <p>Format a rendered reprex reprex as a Python script.</p> <p>Parameters:</p> Name Type Description Default <code>reprex_str</code> <code>str</code> <p>The reprex string to render.</p> required <code>config</code> <code>Optional[ReprexConfig]</code> <p>Configuration for the reprex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The rendered reprex</p> Example <p>2+2</p> Source code in <code>reprexlite/formatting.py</code> <pre><code>@formatter_registry.register(venue=Venue.PY, label=\"Python script\")\ndef format_as_python_script(reprex_str: str, config: Optional[ReprexConfig] = None) -&gt; str:\n    \"\"\"Format a rendered reprex reprex as a Python script.\n\n    Args:\n        reprex_str (str): The reprex string to render.\n        config (Optional[ReprexConfig]): Configuration for the reprex. Defaults to None.\n\n    Returns:\n        str: The rendered reprex\n\n    Example:\n        2+2\n        #&gt; 4\n    \"\"\"\n    if config is None:\n        config = ReprexConfig()\n    advertise = config.advertise if config.advertise is not None else False\n    out = [str(reprex_str)]\n    if advertise:\n        out.append(\"\\n\" + Advertisement().code_comment())\n    if config.session_info:\n        out.append(\"\")\n        sess_lines = str(SessionInfo()).split(\"\\n\")\n        out.extend(\"# \" + line for line in sess_lines)\n    return \"\\n\".join(out) + \"\\n\"\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.format_as_python_script--4","title":"&gt; 4","text":""},{"location":"api-reference/formatting/#reprexlite.formatting.format_as_rtf","title":"format_as_rtf","text":"<pre><code>format_as_rtf(\n    reprex_str: str, config: Optional[ReprexConfig] = None\n) -&gt; str\n</code></pre> <p>Format a rendered reprex reprex as a Rich Text Format (RTF) document. Requires dependency Pygments.</p> Source code in <code>reprexlite/formatting.py</code> <pre><code>@formatter_registry.register(venue=Venue.RTF, label=\"Rich Text Format\")\ndef format_as_rtf(reprex_str: str, config: Optional[ReprexConfig] = None) -&gt; str:\n    \"\"\"Format a rendered reprex reprex as a Rich Text Format (RTF) document. Requires dependency\n    Pygments.\"\"\"\n    if config is None:\n        config = ReprexConfig()\n    advertise = config.advertise if config.advertise is not None else False\n    try:\n        from pygments import highlight\n        from pygments.formatters import RtfFormatter\n        from pygments.lexers import PythonLexer\n    except ModuleNotFoundError as e:\n        if e.name == \"pygments\":\n            raise PygmentsNotFoundError(\"Pygments is required for RTF output.\", name=\"pygments\")\n        else:\n            raise\n\n    out = str(reprex_str)\n    if advertise:\n        out += \"\\n\\n\" + Advertisement().text()\n    if config.session_info:\n        out += \"\\n\\n\" + str(SessionInfo())\n    return highlight(out, PythonLexer(), RtfFormatter()) + \"\\n\"\n</code></pre>"},{"location":"api-reference/formatting/#reprexlite.formatting.format_for_slack","title":"format_for_slack","text":"<pre><code>format_for_slack(\n    reprex_str: str, config: Optional[ReprexConfig] = None\n) -&gt; str\n</code></pre> <p>Format a rendered reprex as Slack markup.</p> <p>Parameters:</p> Name Type Description Default <code>reprex_str</code> <code>str</code> <p>The reprex string to render.</p> required <code>config</code> <code>Optional[ReprexConfig]</code> <p>Configuration for the reprex. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The rendered reprex</p> Example <pre><code>2+2\n#&gt; 4\n</code></pre> Source code in <code>reprexlite/formatting.py</code> <pre><code>@formatter_registry.register(venue=Venue.SLACK, label=\"Slack\")\ndef format_for_slack(reprex_str: str, config: Optional[ReprexConfig] = None) -&gt; str:\n    \"\"\"Format a rendered reprex as Slack markup.\n\n    Args:\n        reprex_str (str): The reprex string to render.\n        config (Optional[ReprexConfig]): Configuration for the reprex. Defaults to None.\n\n    Returns:\n        str: The rendered reprex\n\n    Example:\n        ```\n        2+2\n        #&gt; 4\n        ```\n    \"\"\"\n    if config is None:\n        config = ReprexConfig()\n    advertise = config.advertise if config.advertise is not None else False\n    out = []\n    out.append(\"```\")\n    out.append(str(reprex_str))\n    out.append(\"```\")\n    if advertise:\n        out.append(\"\\n\" + Advertisement().text())\n    if config.session_info:\n        out.append(\"\\n```\")\n        out.append(str(SessionInfo()))\n        out.append(\"```\")\n    return \"\\n\".join(out) + \"\\n\"\n</code></pre>"},{"location":"api-reference/parsing/","title":"reprexlite.parsing","text":""},{"location":"api-reference/parsing/#reprexlite.parsing-classes","title":"Classes","text":""},{"location":"api-reference/parsing/#reprexlite.parsing.LineType","title":"LineType","text":"<p>               Bases: <code>Enum</code></p> <p>An enum for different types of lines in text input to parse.</p> <p>Parameters:</p> Name Type Description Default <code>CODE</code> <code>str</code> <p>Line is code.</p> required <code>RESULT</code> <code>str</code> <p>Line is the result of executing code.</p> required"},{"location":"api-reference/parsing/#reprexlite.parsing-functions","title":"Functions","text":""},{"location":"api-reference/parsing/#reprexlite.parsing.auto_parse","title":"auto_parse","text":"<pre><code>auto_parse(input: str) -&gt; Iterator[Tuple[str, LineType]]\n</code></pre> <p>Automatically parse input that is either doctest-style and reprex-style.</p> Source code in <code>reprexlite/parsing.py</code> <pre><code>def auto_parse(input: str) -&gt; Iterator[Tuple[str, LineType]]:\n    \"\"\"Automatically parse input that is either doctest-style and reprex-style.\"\"\"\n    if any(line.startswith(\"&gt;&gt;&gt;\") for line in input.split(\"\\n\")):\n        yield from parse_doctest(input)\n    else:\n        yield from parse_reprex(input)\n</code></pre>"},{"location":"api-reference/parsing/#reprexlite.parsing.parse","title":"parse","text":"<pre><code>parse(\n    input: str,\n    prompt: Optional[str],\n    continuation: Optional[str],\n    comment: Optional[str],\n) -&gt; Iterator[Tuple[str, LineType]]\n</code></pre> <p>Generator function that parses input into lines of code or results.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>String to parse</p> required <code>prompt</code> <code>Optional[str]</code> <p>Prefix used as primary prompt of code lines</p> required <code>continuation</code> <code>Optional[str]</code> <p>Prefix used as continuation prompt of code lines</p> required <code>comment</code> <code>Optional[str]</code> <p>Prefix used to indicate result lines</p> required <p>Yields:</p> Type Description <code>Tuple[str, LineType]</code> <p>Iterator[Tuple[str, LineType]]: tuple of parsed line and line type</p> Source code in <code>reprexlite/parsing.py</code> <pre><code>def parse(\n    input: str,\n    prompt: Optional[str],\n    continuation: Optional[str],\n    comment: Optional[str],\n) -&gt; Iterator[Tuple[str, LineType]]:\n    \"\"\"Generator function that parses input into lines of code or results.\n\n    Args:\n        input (str): String to parse\n        prompt (Optional[str]): Prefix used as primary prompt of code lines\n        continuation (Optional[str]): Prefix used as continuation prompt of code lines\n        comment (Optional[str]): Prefix used to indicate result lines\n\n    Yields:\n        Iterator[Tuple[str, LineType]]: tuple of parsed line and line type\n    \"\"\"\n    if not any((prompt, continuation, comment)):\n        raise InvalidInputPrefixesError(\n            \"Cannot parse input if all of prompt, continuation, and comment are blank.\"\n        )\n    if len(prompt or \"\") != len(continuation or \"\"):\n        raise PromptLengthMismatchError(\n            f\"Primary prompt ('{prompt}') and continuation prompt ('{continuation}') must be \"\n            \"equal lengths.\"\n        )\n\n    for line_no, line in enumerate(input.split(\"\\n\")):\n        # Case 1: With Prompt/Continuation, no Comment (e.g., doctest style)\n        if prompt and continuation and not comment:\n            if line.startswith(prompt):\n                yield removeprefix(line, prompt), LineType.CODE\n            elif line.startswith(continuation):\n                yield removeprefix(line, continuation), LineType.CODE\n            elif line == \"\":\n                yield line, LineType.CODE\n            else:\n                yield line, LineType.RESULT\n\n        # Case 2: No Prompt or Continuation, with Comment (e.g., reprex style)\n        elif not prompt and not continuation and comment:\n            if line.startswith(comment):\n                yield removeprefix(line, comment), LineType.RESULT\n            else:\n                yield line, LineType.CODE\n\n        # Case 3: Both Prompt/Contiuation and Comment\n        elif prompt and continuation and comment:\n            if line.startswith(prompt):\n                yield removeprefix(line, prompt), LineType.CODE\n            elif line.startswith(continuation):\n                yield removeprefix(line, continuation), LineType.CODE\n            elif line.startswith(comment):\n                yield removeprefix(line, comment), LineType.RESULT\n            elif line == \"\":\n                yield line, LineType.CODE\n            else:\n                raise NoPrefixMatchError(\n                    f\"Line {line_no + 1} does not match any of prompt, continuation, or comment \"\n                    f\"prefixes: '{line}'\"\n                )\n\n        else:\n            raise UnexpectedError(\"Unexpected case when using parse.\")  # pragma: nocover\n</code></pre>"},{"location":"api-reference/parsing/#reprexlite.parsing.parse_doctest","title":"parse_doctest","text":"<pre><code>parse_doctest(input: str) -&gt; Iterator[Tuple[str, LineType]]\n</code></pre> <p>Wrapper around parse for parsing doctest-style input.</p> Source code in <code>reprexlite/parsing.py</code> <pre><code>def parse_doctest(input: str) -&gt; Iterator[Tuple[str, LineType]]:\n    \"\"\"Wrapper around [parse][reprexlite.parsing.parse] for parsing doctest-style input.\"\"\"\n    yield from parse(input=input, prompt=\"&gt;&gt;&gt;\", continuation=\"...\", comment=None)\n</code></pre>"},{"location":"api-reference/parsing/#reprexlite.parsing.parse_reprex","title":"parse_reprex","text":"<pre><code>parse_reprex(input: str) -&gt; Iterator[Tuple[str, LineType]]\n</code></pre> <p>Wrapper around parse for parsing reprex-style input.</p> Source code in <code>reprexlite/parsing.py</code> <pre><code>def parse_reprex(input: str) -&gt; Iterator[Tuple[str, LineType]]:\n    \"\"\"Wrapper around [parse][reprexlite.parsing.parse] for parsing reprex-style input.\"\"\"\n    yield from parse(input=input, prompt=None, continuation=None, comment=\"#&gt;\")\n</code></pre>"},{"location":"api-reference/parsing/#reprexlite.parsing.removeprefix","title":"removeprefix","text":"<pre><code>removeprefix(s: str, prefix: str) -&gt; str\n</code></pre> <p>Utility function to strip a prefix from a string, whether or not there is a single whitespace character.</p> Source code in <code>reprexlite/parsing.py</code> <pre><code>def removeprefix(s: str, prefix: str) -&gt; str:\n    \"\"\"Utility function to strip a prefix from a string, whether or not there is a single\n    whitespace character.\n    \"\"\"\n    if s.startswith(prefix + \" \"):\n        return s[len(prefix) + 1 :]\n    elif s.startswith(prefix):\n        return s[len(prefix) :]\n    else:\n        raise UnexpectedError(  # pragma: nocover\n            \"removeprefix should not be called on input that does not match the prefix. \"\n        )\n</code></pre>"},{"location":"api-reference/reprexes/","title":"reprexlite.reprexes","text":""},{"location":"api-reference/reprexes/#reprexlite.reprexes-classes","title":"Classes","text":""},{"location":"api-reference/reprexes/#reprexlite.reprexes.ParsedResult","title":"ParsedResult  <code>dataclass</code>","text":"<pre><code>ParsedResult(config: ReprexConfig, lines: List[str])\n</code></pre> <p>Class that holds parsed result from reading a reprex.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ReprexConfig</code> <p>Configuration for formatting and parsing</p> required <code>lines</code> <code>List[str]</code> <p>String content of result parsed from a reprex</p> required"},{"location":"api-reference/reprexes/#reprexlite.reprexes.RawResult","title":"RawResult  <code>dataclass</code>","text":"<pre><code>RawResult(\n    config: ReprexConfig, raw: Any, stdout: Optional[str]\n)\n</code></pre> <p>Class that holds the result of evaluated code. Use <code>str(...)</code> on an instance to produce a pretty-formatted comment block representation of the result.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ReprexConfig</code> <p>Configuration for formatting and parsing</p> required <code>raw</code> <code>Any</code> <p>Some Python object that is the raw return value of evaluated Python code.</p> required <code>stdout</code> <code>str</code> <p>Standard output from evaluated Python code.</p> required"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Reprex","title":"Reprex  <code>dataclass</code>","text":"<pre><code>Reprex(\n    config: ReprexConfig,\n    statements: List[Statement],\n    results: List[RawResult],\n    old_results: List[ParsedResult],\n    scope: Dict[str, Any],\n)\n</code></pre> <p>Dataclass for a reprex, which holds Python code and results from evaluation.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ReprexConfig</code> <p>Configuration for formatting and parsing</p> required <code>statements</code> <code>List[Statement]</code> <p>List of parsed Python code statements</p> required <code>results</code> <code>List[RawResult]</code> <p>List of results evaluated from statements</p> required <code>old_results</code> <code>List[ParsedResult]</code> <p>List of any old results parsed from input code</p> required <code>scope</code> <code>Dict[str, Any]</code> <p>Dictionary holding the scope that the reprex was evaluated in</p> required"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Reprex-attributes","title":"Attributes","text":""},{"location":"api-reference/reprexes/#reprexlite.reprexes.Reprex.results_match","title":"results_match  <code>property</code>","text":"<pre><code>results_match: bool\n</code></pre> <p>Whether results of evaluating code match old results parsed from input.</p>"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Reprex-functions","title":"Functions","text":""},{"location":"api-reference/reprexes/#reprexlite.reprexes.Reprex.from_input","title":"from_input  <code>classmethod</code>","text":"<pre><code>from_input(\n    input: str,\n    config: Optional[ReprexConfig] = None,\n    scope: Optional[Dict[str, Any]] = None,\n) -&gt; Self\n</code></pre> <p>Create a Reprex instance from parsing and evaluating code from a string.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>Input code</p> required <code>config</code> <code>Optional[ReprexConfig]</code> <p>Configuration. Defaults to None, which will use default settings.</p> <code>None</code> <code>scope</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary holding scope that the parsed code will be evaluated with. Defaults to None, which will create an empty dictionary.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Reprex</code> <code>Self</code> <p>New instance of Reprex.</p> Source code in <code>reprexlite/reprexes.py</code> <pre><code>@classmethod\ndef from_input(\n    cls,\n    input: str,\n    config: Optional[ReprexConfig] = None,\n    scope: Optional[Dict[str, Any]] = None,\n) -&gt; Self:\n    \"\"\"Create a Reprex instance from parsing and evaluating code from a string.\n\n    Args:\n        input (str): Input code\n        config (Optional[ReprexConfig], optional): Configuration. Defaults to None, which will\n            use default settings.\n        scope (Optional[Dict[str, Any]], optional): Dictionary holding scope that the parsed\n            code will be evaluated with. Defaults to None, which will create an empty\n            dictionary.\n\n    Returns:\n        Reprex: New instance of Reprex.\n    \"\"\"\n    if config is None:\n        config = ReprexConfig()\n    if config.parsing_method == ParsingMethod.AUTO:\n        lines = list(auto_parse(input))\n    elif config.parsing_method == ParsingMethod.DECLARED:\n        lines = list(\n            parse(\n                input,\n                prompt=config.resolved_input_prompt,\n                continuation=config.resolved_input_continuation,\n                comment=config.resolved_input_comment,\n            )\n        )\n    else:\n        raise UnexpectedError(  # pragma: nocover\n            f\"Parsing method {config.parsing_method} is not implemented.\"\n        )\n    return cls.from_input_lines(lines, config=config, scope=scope)\n</code></pre>"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Reprex.from_input_lines","title":"from_input_lines  <code>classmethod</code>","text":"<pre><code>from_input_lines(\n    lines: Sequence[Tuple[str, LineType]],\n    config: Optional[ReprexConfig] = None,\n    scope: Optional[Dict[str, Any]] = None,\n) -&gt; Self\n</code></pre> <p>Creates a Reprex instance from the output of parse.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>Sequence[Tuple[str, LineType]]</code> <p>Output from parse.</p> required <code>config</code> <code>Optional[ReprexConfig]</code> <p>Configuration. Defaults to None, which will use default settings.</p> <code>None</code> <code>scope</code> <code>Optional[Dict[str, Any]]</code> <p>Dictionary holding scope that the parsed code will be evaluated with. Defaults to None, which will create an empty dictionary.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Reprex</code> <code>Self</code> <p>New instance of Reprex.</p> Source code in <code>reprexlite/reprexes.py</code> <pre><code>@classmethod\ndef from_input_lines(\n    cls,\n    lines: Sequence[Tuple[str, LineType]],\n    config: Optional[ReprexConfig] = None,\n    scope: Optional[Dict[str, Any]] = None,\n) -&gt; Self:\n    \"\"\"Creates a Reprex instance from the output of [parse][reprexlite.parsing.parse].\n\n    Args:\n        lines (Sequence[Tuple[str, LineType]]): Output from parse.\n        config (Optional[ReprexConfig], optional): Configuration. Defaults to None, which will\n            use default settings.\n        scope (Optional[Dict[str, Any]], optional): Dictionary holding scope that the parsed\n            code will be evaluated with. Defaults to None, which will create an empty\n            dictionary.\n\n    Returns:\n        Reprex: New instance of Reprex.\n    \"\"\"\n    if config is None:\n        config = ReprexConfig()\n    statements: List[Statement] = []\n    old_results: List[ParsedResult] = []\n    current_code_block: List[str] = []\n    current_result_block: List[str] = []\n    try:\n        for line_content, line_type in lines:\n            if line_type is LineType.CODE:\n                # Flush results\n                if current_result_block:\n                    old_results += [ParsedResult(config=config, lines=current_result_block)]\n                    current_result_block = []\n                # Append line to current code\n                current_code_block.append(line_content)\n            elif line_type is LineType.RESULT:\n                # Flush code\n                if current_code_block:\n                    # Parse code and create Statements\n                    tree: cst.Module = cst.parse_module(\"\\n\".join(current_code_block))\n                    new_statements = (\n                        [Statement(config=config, stmt=stmt) for stmt in tree.header]\n                        + [Statement(config=config, stmt=stmt) for stmt in tree.body]\n                        + [Statement(config=config, stmt=stmt) for stmt in tree.footer]\n                    )\n                    statements += new_statements\n                    # Pad results with empty results, 1 fewer because of current_result_block\n                    old_results += [ParsedResult(config=config, lines=[])] * (\n                        len(new_statements) - 1\n                    )\n                    # Reset current code block\n                    current_code_block = []\n                # Append line to current results\n                current_result_block.append(line_content)\n        # Flush code\n        if current_code_block:\n            if all(not line for line in current_code_block):\n                # Case where all lines are whitespace: strip and don't add\n                new_statements = []\n            else:\n                # Parse code and create Statements\n                tree: cst.Module = cst.parse_module(  # type: ignore[no-redef]\n                    \"\\n\".join(current_code_block)\n                )\n                new_statements = (\n                    [Statement(config=config, stmt=stmt) for stmt in tree.header]\n                    + [Statement(config=config, stmt=stmt) for stmt in tree.body]\n                    + [Statement(config=config, stmt=stmt) for stmt in tree.footer]\n                )\n            # Pad results with empty results, 1 fewer because of current_result_block\n            statements += new_statements\n            old_results += [ParsedResult(config=config, lines=[])] * (len(new_statements) - 1)\n        # Flush results\n        if current_result_block:\n            old_results += [ParsedResult(config=config, lines=current_result_block)]\n        # Pad results to equal length\n        old_results += [ParsedResult(config=config, lines=[])] * (\n            len(statements) - len(old_results)\n        )\n\n        # Evaluate for new results\n        if scope is None:\n            scope = {}\n        results = [statement.evaluate(scope=scope) for statement in statements]\n        return cls(\n            config=config,\n            statements=statements,\n            results=results,\n            old_results=old_results,\n            scope=scope,\n        )\n    except cst.ParserSyntaxError as e:\n        raise InputSyntaxError(str(e)) from e\n</code></pre>"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Reprex.render","title":"render","text":"<pre><code>render(terminal: bool = False) -&gt; str\n</code></pre> <p>Render the reprex as code.</p> Source code in <code>reprexlite/reprexes.py</code> <pre><code>def render(self, terminal: bool = False) -&gt; str:\n    \"\"\"Render the reprex as code.\"\"\"\n    if self.config.keep_old_results:\n        lines = chain.from_iterable(zip(self.statements, self.old_results, self.results))\n    else:\n        lines = chain.from_iterable(zip(self.statements, self.results))\n    out = \"\\n\".join(str(line) for line in lines if line)\n    if not out.endswith(\"\\n\"):\n        out += \"\\n\"\n    # if terminal=True and Pygments is available, apply syntax highlighting\n    if terminal:\n        try:\n            from pygments import highlight\n            from pygments.formatters import Terminal256Formatter\n            from pygments.lexers import PythonLexer\n\n            out = highlight(out, PythonLexer(), Terminal256Formatter(style=\"friendly\"))\n        except ModuleNotFoundError:\n            pass\n    return out\n</code></pre>"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Reprex.render_and_format","title":"render_and_format","text":"<pre><code>render_and_format(terminal: bool = False) -&gt; str\n</code></pre> <p>Render the reprex as code and format it for the configured output venue.</p> Source code in <code>reprexlite/reprexes.py</code> <pre><code>def render_and_format(self, terminal: bool = False) -&gt; str:\n    \"\"\"Render the reprex as code and format it for the configured output venue.\"\"\"\n    out = self.render(terminal=terminal)\n    formatter_fn = formatter_registry[self.config.venue].fn\n    return formatter_fn(out.strip(), config=self.config)\n</code></pre>"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Statement","title":"Statement  <code>dataclass</code>","text":"<pre><code>Statement(\n    config: ReprexConfig,\n    stmt: Union[\n        cst.SimpleStatementLine,\n        cst.BaseCompoundStatement,\n        cst.EmptyLine,\n    ],\n)\n</code></pre> <p>Dataclass that holds a LibCST parsed statement. of code.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ReprexConfig</code> <p>Configuration for formatting and parsing</p> required <code>stmt</code> <code>Union[SimpleStatementLine, BaseCompoundStatement]</code> <p>LibCST parsed statement.</p> required"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Statement-attributes","title":"Attributes","text":""},{"location":"api-reference/reprexes/#reprexlite.reprexes.Statement.code","title":"code  <code>property</code>","text":"<pre><code>code: str\n</code></pre> <p>Code of contained statement. May be autoformatted depending on configuration.</p>"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Statement.raw_code","title":"raw_code  <code>property</code>","text":"<pre><code>raw_code: str\n</code></pre> <p>Raw code of contained statement as a string.</p>"},{"location":"api-reference/reprexes/#reprexlite.reprexes.Statement-functions","title":"Functions","text":""},{"location":"api-reference/reprexes/#reprexlite.reprexes.Statement.evaluate","title":"evaluate","text":"<pre><code>evaluate(scope: dict) -&gt; RawResult\n</code></pre> <p>Evaluate code statement and produce a RawResult dataclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>scope</code> <code>dict</code> <p>scope to use for evaluation</p> required <p>Returns:</p> Name Type Description <code>RawResult</code> <code>RawResult</code> <p>Dataclass instance holding evaluation results.</p> Source code in <code>reprexlite/reprexes.py</code> <pre><code>def evaluate(self, scope: dict) -&gt; RawResult:\n    \"\"\"Evaluate code statement and produce a RawResult dataclass instance.\n\n    Args:\n        scope (dict): scope to use for evaluation\n\n    Returns:\n        RawResult: Dataclass instance holding evaluation results.\n    \"\"\"\n    if isinstance(self.stmt, cst.EmptyLine):\n        return RawResult(config=self.config, raw=None, stdout=None)\n\n    if \"__name__\" not in scope:\n        scope[\"__name__\"] = \"__reprex__\"\n    stdout_io = StringIO()\n    try:\n        with redirect_stdout(stdout_io):\n            try:\n                # Treat as a single expression\n                result = eval(self.code.strip(), scope)\n            except SyntaxError:\n                # Treat as a statement\n                exec(self.code.strip(), scope)\n                result = None\n        stdout = stdout_io.getvalue().strip()\n    except Exception as exc:\n        result = None\n        # Skip first step of traceback, since that is this evaluate method\n        if exc.__traceback__ is not None:\n            tb = exc.__traceback__.tb_next\n            stdout = (\n                \"Traceback (most recent call last):\\n\"\n                + \"\".join(line for line in traceback.format_tb(tb))\n                + f\"{type(exc).__name__}: {exc}\"\n            )\n    finally:\n        stdout_io.close()\n\n    return RawResult(config=self.config, raw=result, stdout=stdout or None)\n</code></pre>"},{"location":"api-reference/reprexes/#reprexlite.reprexes-functions","title":"Functions","text":""},{"location":"api-reference/reprexes/#reprexlite.reprexes.reprex","title":"reprex","text":"<pre><code>reprex(\n    input: str,\n    outfile: Optional[Union[str, os.PathLike]] = None,\n    print_: bool = True,\n    terminal: bool = False,\n    config: Optional[ReprexConfig] = None,\n    **kwargs,\n) -&gt; Reprex\n</code></pre> <p>A convenient functional interface to render reproducible examples of Python code for sharing. This function will evaluate your code and, by default, print out your code with the evaluated results embedded as comments, formatted with additional markup appropriate to the sharing venue set by the <code>venue</code> keyword argument. The function returns an instance of <code>Reprex</code> which holds the relevant data.</p> <p>For example, for the <code>gh</code> venue for GitHub Flavored Markdown, you'll get a reprex whose formatted output looks like:</p> <pre><code>```python\nx = 2\nx + 2\n#&gt; 4\n```\n\n&lt;sup&gt;Created at 2021-02-15 16:58:47 PST by [reprexlite](https://github.com/jayqi/reprexlite)&lt;/sup&gt;\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>Input code to create a reprex for.</p> required <code>outfile</code> <code>Optional[str | PathLike]</code> <p>If provided, path to write formatted reprex output to. Defaults to None, which does not write to any file.</p> <code>None</code> <code>print_</code> <code>bool</code> <p>Whether to print formatted reprex output to console.</p> <code>True</code> <code>terminal</code> <code>bool</code> <p>Whether currently in a terminal. If true, will automatically apply code highlighting if pygments is installed.</p> <code>False</code> <code>config</code> <code>Optional[ReprexConfig]</code> <p>Instance of the configuration dataclass. Default of none will instantiate one with default values.</p> <code>None</code> <code>**kwargs</code> <p>Configuration options from ReprexConfig. Any provided values will override values from provided config or the defaults.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Reprex</code> <p>(Reprex) Reprex instance</p> Source code in <code>reprexlite/reprexes.py</code> <pre><code>def reprex(\n    input: str,\n    outfile: Optional[Union[str, os.PathLike]] = None,\n    print_: bool = True,\n    terminal: bool = False,\n    config: Optional[ReprexConfig] = None,\n    **kwargs,\n) -&gt; Reprex:\n    \"\"\"A convenient functional interface to render reproducible examples of Python code for\n    sharing. This function will evaluate your code and, by default, print out your code with the\n    evaluated results embedded as comments, formatted with additional markup appropriate to the\n    sharing venue set by the `venue` keyword argument. The function returns an instance of\n    [`Reprex`][reprexlite.reprexes.Reprex] which holds the relevant data.\n\n    For example, for the `gh` venue for GitHub Flavored Markdown, you'll get a reprex whose\n    formatted output looks like:\n\n    ````\n    ```python\n    x = 2\n    x + 2\n    #&gt; 4\n    ```\n\n    &lt;sup&gt;Created at 2021-02-15 16:58:47 PST by [reprexlite](https://github.com/jayqi/reprexlite)&lt;/sup&gt;\n    ````\n\n\n    Args:\n        input (str): Input code to create a reprex for.\n        outfile (Optional[str | os.PathLike]): If provided, path to write formatted reprex\n            output to. Defaults to None, which does not write to any file.\n        print_ (bool): Whether to print formatted reprex output to console.\n        terminal (bool): Whether currently in a terminal. If true, will automatically apply code\n            highlighting if pygments is installed.\n        config (Optional[ReprexConfig]): Instance of the configuration dataclass. Default of none\n            will instantiate one with default values.\n        **kwargs: Configuration options from [ReprexConfig][reprexlite.config.ReprexConfig]. Any\n            provided values will override values from provided config or the defaults.\n\n    Returns:\n        (Reprex) Reprex instance\n    \"\"\"  # noqa: E501\n\n    if config is None:\n        config = ReprexConfig(**kwargs)\n    else:\n        config = dataclasses.replace(config, **kwargs)\n\n    config = ReprexConfig(**kwargs)\n    if config.venue in [\"html\", \"rtf\"]:\n        # Don't screw up output file or lexing for HTML and RTF with terminal syntax highlighting\n        terminal = False\n    r = Reprex.from_input(input, config=config)\n    output = r.render_and_format(terminal=terminal)\n    if outfile is not None:\n        with Path(outfile).open(\"w\") as fp:\n            fp.write(r.render_and_format(terminal=False))\n    if print_:\n        print(output)\n    return r\n</code></pre>"},{"location":"api-reference/session_info/","title":"reprexlite.session_info","text":""},{"location":"api-reference/session_info/#reprexlite.session_info-classes","title":"Classes","text":""},{"location":"api-reference/session_info/#reprexlite.session_info.Package","title":"Package","text":"<pre><code>Package(distribution: importlib.metadata.Distribution)\n</code></pre> <p>Interface for adapting <code>importlib.metadata.Distribution</code> instances for introspection by <code>SessionInfo</code>.</p> Source code in <code>reprexlite/session_info.py</code> <pre><code>def __init__(self, distribution: importlib.metadata.Distribution):\n    self.distribution = distribution\n</code></pre>"},{"location":"api-reference/session_info/#reprexlite.session_info.SessionInfo","title":"SessionInfo","text":"<pre><code>SessionInfo()\n</code></pre> <p>Class for pretty-formatting Python session info. Includes details about your Python version, your operating system, and the Python packages installed in your current environment.</p> <p>Attributes:</p> Name Type Description <code>python_version</code> <code>str</code> <p>Python version for current session</p> <code>python_build_date</code> <code>str</code> <p>Date</p> <code>os</code> <code>str</code> <p>OS information for current session</p> <code>packages</code> <code>List[Package]</code> <p>List of Python packages installed in current virtual environment.</p> Source code in <code>reprexlite/session_info.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.python_version: str = platform.python_version()\n    self.python_build_date: str = platform.python_build()[1]\n\n    self.os: str = platform.platform()\n    self.packages: List[Package] = [\n        Package(distr) for distr in importlib.metadata.Distribution.discover()\n    ]\n</code></pre>"},{"location":"api-reference/session_info/#reprexlite.session_info-functions","title":"Functions","text":""},{"location":"api-reference/session_info/#reprexlite.session_info.tabulate","title":"tabulate","text":"<pre><code>tabulate(rows: List[Tuple[str, str]]) -&gt; List[str]\n</code></pre> <p>Utility function for printing a two-column table as text with whitespace padding.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>List[Tuple[str, str]]</code> <p>Rows of table as tuples of (left cell, right cell)</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>Rows of table formatted as strings with whitespace padding</p> Source code in <code>reprexlite/session_info.py</code> <pre><code>def tabulate(rows: List[Tuple[str, str]]) -&gt; List[str]:\n    \"\"\"Utility function for printing a two-column table as text with whitespace padding.\n\n    Args:\n        rows (List[Tuple[str, str]]): Rows of table as tuples of (left cell, right cell)\n\n    Returns:\n        Rows of table formatted as strings with whitespace padding\n    \"\"\"\n    left_max = max(len(row[0]) for row in rows)\n    out = []\n    for left, right in rows:\n        padding = (left_max + 1 - len(left)) * \" \"\n        out.append(left + padding + right)\n    return out\n</code></pre>"}]}